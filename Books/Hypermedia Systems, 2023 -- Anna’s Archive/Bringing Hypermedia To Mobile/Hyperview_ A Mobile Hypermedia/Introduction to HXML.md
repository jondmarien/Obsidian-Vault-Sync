# Introduction to HXML

## Hello World!

HXML was designed to feel natural to web developers coming from HTML. Let’s take a closer look at the “Hello World” app defined in HXML:

    <doc xmlns="https://hyperview.org/hyperview"> <1>
      <screen> <2>
        <styles />
        <body> <3>
          <header> <4>
            <text>My first apptext>
          header>
          <view> <5>
            <text>Hello World!text> <6>
          view>
        body>
      screen>
    doc>

Hello World, revisited

1.  The root element of the HXML app
    
2.  The element representing a screen of the app
    
3.  The element representing the UI of the screen
    
4.  The element representing the top header of the screen
    
5.  A wrapper element around the content shown on the screen
    
6.  The text content shown on the screen
    

Nothing too strange here, right? Just like HTML, the syntax defines a tree of elements using start tags () and end tags (). Elements can contain other elements () or text (`Hello World!`). Elements can also be empty, represented with an empty tag (). However, you’ll notice that the names of the HXML element are different from those in HTML. Let’s take a closer look at each of those elements to understand what they do.

is the root of the HXML app. Think of it as equivalent to the element in HTML. Note that the element contains an attribute `xmlns="https://hyperview.org/hyperview"`. This defines the default namespace for the doc. Namespaces are a feature of XML that allow one doc to contain elements defined by different developers. To prevent conflicts when two developers use the same name for their element, each developer defines a unique namespace. We will talk more about namespaces when we discuss custom elements & behaviors later in this chapter. For now, it’s enough to know that elements in a HXML doc without an explicit namespace are considered to be part of the `https://hyperview.org/hyperview` namespace.

represents the UI that gets rendered on a single screen of a mobile app. It’s possible for one to contain multiple elements, but we won’t get into that now. Typically, a element will contain elements that define the content and styling of the screen.

defines the styles of the UI on the screen. We won’t get too much into styling in Hyperview in this chapter. Suffice it to say, unlike HTML, Hyperview does not use a separate language (CSS) to define styles. Instead, styling rules such as colors, spacing, layout, and fonts are defined in HXML. These rules are then explicitly referenced by UI elements, much like using classes in CSS.

defines the actual UI of the screen. The body includes all text, images, buttons, forms, etc that will be shown to the user. This is equivalent to the element in HTML.

defines the header of the screen. Typically in mobile apps, the header includes some navigation (like a back button), and the title of the screen. It’s useful to define the header separately from the rest of the body. Some mobile OSes will use a different transition for the header than the rest of the screen content.

is the basic building block for layouts and structure within the screen’s body. Think of it like a

in HTML. Note that unlike in HTML, a

cannot directly contain text.

elements are the only way to render text in the UI. In this example, “Hello World” is contained within a element.

That’s all there is to define a basic “Hello World” app in HXML. Of course, this isn’t very exciting. Let’s cover some other built-in display elements.

## UI Elements

### Lists

A very common pattern in mobile apps is to scroll through a list of items. The physical properties of a phone screen (long & vertical) and the intuitive gesture of swiping a thumb up & down makes this a good choice for many screens.

HXML has dedicated elements for representing lists and items.

    <list> <1>
      <item key="item1"> <2>
        <text>My first itemtext> <3>
      item>
      <item key="item2">
        <text>My second itemtext>
      item>
    list>

List element

1.  Element representing a list
    
2.  Element representing an item in the list, with a unique key
    
3.  The content of the item in the list.
    

Lists are represented with two new elements. The wraps all of the items in the list. It can be styled like a generic (width, height, etc). A element only contains elements. Of course, these represent each unique item in the list. Note that is required to have a `key` attribute, which is unique among all items in the list.

You might be asking, “Why do we need a custom syntax for lists of items? Can’t we just use a bunch of elements?”. Yes, for lists with a small number of items, using nested will work quite well. However, often the number of items in a list can be long enough to require optimizations to support smooth scrolling interactions. Consider browsing a feed of posts in a social media app. As you keep scrolling through the feed, it’s not unusual for the app to show hundreds if not thousands of posts. At any time, you can flick your finger to scroll to almost any part of the feed. Mobile devices tend to be memory-constrained. Keeping the fully-rendered list of items in memory could consume more resources than available. That’s why both iOS and Android provide APIs for optimized list UIs. These APIs know which part of the list is currently on-screen. To save memory, they clear out the non-visible list items, and recycle the item UI objects to conserve memory. By using explicit and elements in HXML, the Hyperview client knows to use these optimized list APIs to make your app more performant.

It’s also worth mentioning that HXML supports section lists. Section lists are useful for building list-based UIs, where the items in the list can be grouped for the user’s convenience. For example, a UI showing a restaurant menu could group the offerings by dish type:

    <section-list> <1>
      <section> <2>
        <section-title> <3>
          <text>Appetizerstext>
        section-title>
        <item key="1"> <4>
          <text>French Friestext>
        item>
        <item key="2">
          <text>Onion Ringstext>
        item>
      section>
    
      <section> <5>
        <section-title>
          <text>Entreestext>
        section-title>
        <item key="3">
          <text>Burgertext>
        item>
      section>
    section-list>

Section list element

1.  Element representing a list with sections
    
2.  The first section of appetizer offerings
    
3.  Element for the title of the section, rendering the text “Appetizers”
    
4.  An item representing an appetizer
    
5.  A section for entree offerings
    

You’ll notice a couple of differences between and . The section list element only contains

elements, representing a group of items. A section can contain a element. This is used to render some UI that acts as the header of the section. This header is “sticky”, meaning it stays on screen while scrolling through items that belong to the corresponding section. Finally, elements act the same as in the regular list, but can only appear within a

.

### Images

Showing images in Hyperview is pretty similar to HTML, but there are a few differences.

    <image source="/profiles/1.jpg" style="avatar" />

Image element

The `source` attribute specifies how to load the image. Like in HTML, the source can be an absolute or relative URL. Additionally, the source can be an encoded data URI, for example `data:image/png;base64,iVBORw`. However, the source can also be a “local” URL, referring to an image that is bundled as an asset in the mobile app. The local URL is prefixed with `./`:

    <image source="./logo.png" style="logo" />

Image element, pointing to local source

Using Local URLs is an optimization. Since the images are on the mobile device, they don’t require a network request and will appear quickly. However, bundling the image with the mobile app binary increases the binary size. Using local images is a good trade-off for images that are frequently accessed but rarely change. Good examples include the app logo, or common button icons.

The other thing to note is the presence of the `style` attribute on the `![](/Hypermedia%20Systems,%202023%20--%20Anna’s%20Archive/images)` element. In HXML, images are required to have a style that has rules for the image’s `width` and `height`. This is different from HTML, where `![](/Hypermedia%20Systems,%202023%20--%20Anna’s%20Archive/images)` elements do not need to explicitly set a width and height. web browsers will re-flow the content of a web page once the image is fetched and the dimensions are known. While re-flowing content is a reasonable behavior for web-based documents, users do not expect mobile apps to re-flow as content loads. To maintain a static layout, HXML requires the dimensions to be known before the image loads.

## Inputs

There’s a lot to cover about inputs in Hyperview. Since this is meant to be an introduction and not an exhaustive resource, I’ll highlight just a few types of inputs. Let’s start with an example of the simplest type of input, a text field.

    <text-field
      name="first_name" <1>
      style="input" <2>
      value="Adam" <3>
      placeholder="First name" <4>
    />

Text field element

1.  The name used when serializing data from this input
    
2.  The style class applied to the UI element
    
3.  The current value set in the field
    
4.  A placeholder to display when the value is empty
    

This element should feel familiar to anyone who’s created a text field in HTML. One difference is that most inputs in HTML use the  element with a `type` attribute, eg . In Hyperview, each input has a unique name, in this case . By using different names, we can use more expressive XML to represent the input.

For example, let’s consider a case where we want to render a UI that lets the user select one among several options. In HTML, we would use a radio button input, something like . Each choice is represented as a unique input element. This never struck me as ideal. Most of the time, radio buttons are grouped together to affect the same name. The HTML approach leads to a lot of boilerplate (duplication of `type="radio"` and `name="choice"` for each choice). Also, unlike radio buttons on desktop, mobile OSes don’t provide a strong standard UI for selecting one option. Most mobile apps use richer, custom UIs for these interactions. So in HXML, we implement this UI using an element called :

    <select-single name="choice"> <1>
      <option value="option1"> <2>
        <text>Option 1text> <3>
      option>
      <option value="option2">
        <text>Option 2text>
      option>
    select-single>

Select-single element

1.  Element representing an input where a single choice is selected. The name of the selection is defined once here.
    
2.  Element representing one of the choices. The choice value is defined here.
    
3.  The UI of the selection. In this example, we use text, but we can use any UI elements.
    

The element is the parent of the input for selecting one choice out of many. This element contains the `name` attribute used when serializing the selected choice. elements within represent the available choices. Note that each element has a `value` attribute. When pressed, this will be the selected value of the input. The element can contain any other UI elements within it. This means that we’re not hampered by rendering the input as a list of radio buttons with labels. We can render the options as radios, tags, images, or anything else that would be intuitive for our interface. HXML styling supports modifiers for pressed and selected states, letting us customize the UI to highlight the selected option.

Describing all features of inputs in HXML would take an entire chapter. Instead, I’ll summarize a few other input elements and their features.

\- works like , but it supports toggling multiple options on & off. This replaces checkbox inputs in HTML. - The element renders an on/off switch that is common in mobile UIs - The element supports entering in specific dates, and comes with a wide range of customizations for formatting, settings ranges, etc.

Two more things to mention about inputs. First is the

element. The element is used to group together inputs for serialization. When a user takes an action that triggers a backend request, the Hyperview client will serialize all inputs in the surrounding and include them in the request. This is true for both `GET` and `POST` requests. We will cover this in more detail when talking about behaviors later in this chapter. Also later in this chapter, I’ll talk about support for custom elements in HXML. With custom elements, you can also create your own input elements. Custom input elements allow you to build incredible powerful interactions with simple XML syntax that integrates well with the rest of HXML.

## Styling

So far, we haven’t mentioned how to apply styling to all of the HXML elements. We’ve seen from the Hello World app that each can contain a element. Let’s re-visit the Hello World app and fill out the element.

    <doc xmlns="https://hyperview.org/hyperview">
      <screen>
        <styles> <1>
          <style class="body" flex="1" flexDirection="column" /> <2>
          <style class="header"
            borderBottomWidth="1" borderBottomColor="#ccc" />
          <style class="main" margin="24" />
          <style class="h1" fontSize="32" />
          <style class="info" color="blue" />
        styles>
    
        <body style="body"> <3>
          <header style="header">
            <text style="info">My first apptext>
          header>
          <view style="main">
            <text style="h1 info">Hello World!text> <4>
          view>
        body>
      screen>
    doc>

UI styling example

1.  Element encapsulating all of the styling for the screen
    
2.  Example of a definition of a style class for “body”
    
3.  Applying the “body” style class to a UI element
    
4.  Example of applying multiple style classes (h1 and info) to an element
    

You’ll note that in HXML, styling is part of the XML format, rather than using a separate language like CSS. However, we can draw some parallels between CSS rules and the `</code> element. A CSS rule consists of a selector and declarations. In the current version of HXML, the only available selector is a class name, indicated by the <code>class</code> attribute. The rest of the attributes on the <code><style></code> element are declarations, consisting of properties and property values.</p> <p>UI elements within the <code><screen></code> can reference the <code><style></code> rules by adding the class names to their <code><style></code> property. Note the <code><text></code> element around “Hello World!” references two style classes: <code>h1</code> and <code>info</code>. The styles from the corresponding classes are merged together in the order they appear on the element. It’s worth noting that styling properties are similar to those in CSS (color, margins/padding, borders, etc). Currently, the only available layout engine is based on flexbox.</p> <p>Style rules can get quite verbose. For the sake of brevity, we won’t include the <code><styles></code> element in the rest of the examples in this chapter unless necessary.</p> </section> <section id="custom-elements" class="level4"> <h4>Custom elements</h4> <p>The core UI elements that ship with Hyperview are quite basic. Most mobile apps require richer elements to deliver a great user experience. Luckily, HXML can easily accommodate custom elements in its syntax. This is because HXML is really just XML, aka “Extensible Markup Language”. Extensibility is already built into the format! Developers are free to define new elements and attributes to represent custom elements.</p> <p>Let’s see this in action with a concrete example. Assume that we want to add a map element to our Hello World app. We want the map to display a defined area, and one or more markers at specific coordinates in that area. Let’s translate these requirements into XML:</p> <ul> <li><p>An <code><area></code> element will represent the area displayed by the map. To specify the area, the element will include attributes for <code>latitude</code> and <code>longitude</code> for the center of the area, and a <code>latitude-delta</code> and <code>longitude-delta</code> indicating the +/- display area around the center.</p></li> <li><p>A <code><marker></code> element will represent a marker in the area. The coordinates of the marker will be defined by <code>latitude</code> and <code>longitude</code> attributes on the marker.</p></li> </ul> <p>Using these custom XML elements, an instance of the map in our app might look like this:</p> <figure> <div class="sourceCode" id="cb12"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">doc</span><span class="ot"> xmlns=</span><span class="st">"https://hyperview.org/hyperview"</span>></span> <span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">screen</span>></span> <span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span>></span> <span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Hello World!</<span class="kw">text</span>></span> <span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a> <<span class="kw">area</span><span class="ot"> latitude=</span><span class="st">"37.8270"</span><span class="ot"> longitude=</span><span class="st">"122.4230"</span></span> <span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="ot"> latitude-delta=</span><span class="st">"0.1"</span><span class="ot"> longitude-delta=</span><span class="st">"0.1"</span>> <span class="er"><</span>1></span> <span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a> <<span class="kw">marker</span><span class="ot"> latitude=</span><span class="st">"37.8118"</span><span class="ot"> longitude=</span><span class="st">"-122.4177"</span> /> <span class="er"><</span>2></span> <span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a> </<span class="kw">area</span>></span> <span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a> </<span class="kw">screen</span>></span> <span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></<span class="kw">doc</span>></span></code></pre></div> <figcaption><p>Custom elements in HXML</p></figcaption> </figure> <ol> <li><p>Custom element representing the area rendered by the map</p></li> <li><p>Custom element representing a marker rendered at specific coordinates on the map</p></li> </ol> <p>The syntax feels right at home among the core HXML elements. However, there’s a potential problem. “area” and “marker” are pretty generic names. I could see <code><area></code> and <code><marker></code> elements being used by a customization to render charts & graphs. If our app renders both maps and charts, the HXML markup would be ambiguous. What should the client render when it sees <code><area></code> or <code><marker></code>?</p> <p>This is where XML namespaces come in. XML namespaces eliminate ambiguity and collisions between elements and attributes used to represent different things. Remember that the <code><doc></code> element declares that <code>https://hyperview.org/hyperview</code> is the default namespace for the entire document. Since no other elements define namespaces, every element in the example above is part of the <code>https://hyperview.org/hyperview</code> namespace.</p> <p>Let’s define a new namespace for our map elements. Since this namespace will not be the default for the document, we also need to assign the namespace to a prefix we will add to our elements:</p> <figure> <div class="sourceCode" id="cb13"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">doc</span><span class="ot"> xmlns=</span><span class="st">"https://hyperview.org/hyperview"</span></span> <span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot"> xmlns:map=</span><span class="st">"https://mycompany.com/hyperview-map"</span>></span></code></pre></div> </figure> <p>This new attribute declares that the <code>map:</code> prefix is associated with the namespace “https://mycompany.com/hyperview-map”. This namespace could be anything, but remember the goal is to use something unique that won’t have collisions. Using your company/app domain is a good way to guarantee uniqueness. Now that we have a namespace and prefix, we need to use it for our elements:</p> <figure> <div class="sourceCode" id="cb14"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">doc</span><span class="ot"> xmlns=</span><span class="st">"https://hyperview.org/hyperview"</span></span> <span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot"> xmlns:map=</span><span class="st">"https://mycompany.com/hyperview-map"</span>> <span class="er"><</span>1></span> <span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">screen</span>></span> <span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span>></span> <span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Hello World!</<span class="kw">text</span>></span> <span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a> <<span class="kw">map:area</span><span class="ot"> latitude=</span><span class="st">"37.8270"</span><span class="ot"> longitude=</span><span class="st">"122.4230"</span></span> <span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="ot"> latitude-delta=</span><span class="st">"0.1"</span><span class="ot"> longitude=</span><span class="er">delta=</span><span class="st">"0.1"</span>> <span class="er"><</span>2></span> <span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a> <<span class="kw">map:marker</span><span class="ot"> latitude=</span><span class="st">"37.8118"</span><span class="ot"> longitude=</span><span class="st">"-122.4177"</span> /> <span class="er"><</span>3></span> <span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a> </<span class="kw">map:area</span>> <span class="er"><</span>4></span> <span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a> </<span class="kw">screen</span>></span> <span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></<span class="kw">doc</span>></span></code></pre></div> <figcaption><p>Namespacing the custom elements</p></figcaption> </figure> <ol> <li><p>Definition of namespace aliased to “map”</p></li> <li><p>Adding the namespace to the “area” start tag</p></li> <li><p>Adding the namespace to the “marker” self-closing tag</p></li> <li><p>Adding the namespace to the “area” end tag</p></li> </ol> <p>That’s it! If we introduced a custom charting library with “area” and “marker” elements, we would create a unique namespace for those elements as well. Within the HXML doc, we could easily disambiguate <code><map:area></code> from <code><chart:area></code>.</p> <p>At this point you might be wondering, “how does the Hyperview client know to render a map when my doc includes <map:area>?” It’s true, so far we only defined the custom element format, but we haven’t implemented the element as a feature in our app. We will get into the details of implementing custom elements in the next chapter.</p> </section> <section id="id__behaviors" class="level4"> <h4>Behaviors</h4> <p>As discussed in earlier chapters, HTML supports two basic types of interactions:</p> <ul> <li><p>Clicking a hyperlink: the client will make a GET request and render the response as a new web page.</p></li> <li><p>Submitting a form: the client will (typically) make a POST request with the serialized content of the form, and render the response as a new web page.</p></li> </ul> <p>Clicking hyperlinks and submitting forms is enough to build simple web applications. But relying on just these two interactions limits our ability to build richer UIs. What if we want something to happen when the user mouses over a certain element, or perhaps when they scroll some content into the viewport? We can’t do that with basic HTML. Additionally, both clicks and form submits result in loading a full new web page. What if we only want to update a small part of the current page? This is a very common scenario in rich web applications, where users expect to fetch and update content without navigating to a new page.</p> <p>So with basic HTML, interactions (clicks and submits) are limited and tightly coupled to a single action (loading a new page). Of course, using JavaScript, we can extend HTML and add some new syntax to support our desired interactions. Htmx does exactly that with a new set of attributes:</p> <ul> <li><p>Interactions can be added to any element, not just links and forms.</p></li> <li><p>The interaction can be triggered via a click, submit, mouseover, or any other JavaScript event.</p></li> <li><p>The actions resulting from the trigger can modify the current page, not just request a new page.</p></li> </ul> <p>By decoupling elements, triggers, and actions, htmx allows us to build rich Hypermedia-driven applications in a way that feels very compatible with HTML syntax and server-side web development.</p> <p>HXML takes the idea of defining interactions via triggers & actions and builds them into the spec. We call these interactions “behaviors.” We use a special <code><behavior></code> element to define them. Here’s an example of a simple behavior that pushes a new mobile screen onto the navigation stack:</p> <figure> <div class="sourceCode" id="cb15"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">text</span>></span> <span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span> <span class="er"><1</span>></span> <span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a> trigger="press" <span class="er"><</span>2></span> <span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a> action="push" <span class="er"><</span>3></span> <span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a> href="/next-screen" <span class="er"><</span>4></span> <span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a> /></span> <span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a> Press me!</span> <span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></<span class="kw">text</span>></span></code></pre></div> <figcaption><p>Basic behavior</p></figcaption> </figure> <ol> <li><p>The element encapsulating an interaction on the parent <code><text></code> element.</p></li> <li><p>The trigger that will execute the interaction, in this case pressing the <code><text></code> element.</p></li> <li><p>The action that will execute when triggered, in this case pushing a new screen onto the current stack.</p></li> <li><p>The href to load on the new screen.</p></li> </ol> <p>Let’s break down what’s happening in this example. First, we have a <code><text></code> element with the content “Press me!”. We’ve shown <code><text></code> elements before in examples of HXML, so this is nothing new. But now, the <code><text></code> element contains a new child element, <code><behavior></code>. This <code><behavior></code> element defines an interaction on the parent <code><text></code> element. It contains two attributes that are required for any behavior:</p> <ul> <li><p><code>trigger</code>: defines the user action that triggers the behavior</p></li> <li><p><code>action</code>: defines what happens when triggered</p></li> </ul> <p>In this example, the <code>trigger</code> is set to <code>press</code>, meaning this interaction will happen when the user presses the <code><text></code> element. The <code>action</code> attribute is set to <code>push</code>. <code>push</code> is an action that will push a new screen onto the navigation stack. Finally, Hyperview needs to know what content to load on the newly pushed screen. This is where the <code>href</code> attribute comes in. Notice we don’t need to define the full URL. Much like in HTML, the <code>href</code> can be an absolute or relative URL.</p> <p>So that’s a first example of behaviors in HXML. You may be thinking this syntax seems quite verbose. Indeed, pressing elements to navigate to a new screen is one of the most common interactions in a mobile app. It would be nice to have a simpler syntax for the common case. Luckily, <code>trigger</code> and <code>action</code> attributes have default values of <code>press</code> and <code>push</code>, respectively. Therefore, they can be omitted to clean up the syntax:</p> <figure> <div class="sourceCode" id="cb16"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">text</span>></span> <span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> href=</span><span class="st">"/next-screen"</span> /> <span class="er"><</span>1></span> <span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a> Press me!</span> <span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></<span class="kw">text</span>></span></code></pre></div> <figcaption><p>Basic behavior with defaults</p></figcaption> </figure> <ol> <li><p>When pressed, this behavior will open a new screen with the given URL.</p></li> </ol> <p>This markup for the <code><behavior></code> will produce the same interaction as the earlier example. With the default attributes, the <code><behavior></code> element looks similar to an anchor <code><a></code> in HTML. But the full syntax achieves our goals of decoupling elements, triggers, and actions:</p> <ul> <li><p>Behaviors can be added to any element, they are not limited to links and forms.</p></li> <li><p>Behaviors can specify an explicit <code>trigger</code>, not just clicks or form submits.</p></li> <li><p>Behaviors can specify an explicit <code>action</code>, not just a request for a new page.</p></li> <li><p>Extra attributes like <code>href</code> provide more context for the action.</p></li> </ul> <p>Additionally, using a dedicated <code><behavior></code> element means a single element can define multiple behaviors. This lets us execute several actions from the same trigger. Or, we can execute different actions for different triggers on the same element. We will show examples of the power of multiple behaviors at the end of this chapter. First we need to show the variety of supported actions and triggers.</p> <section id="actions" class="level5"> <h5>Actions</h5> <p>Behavior actions in Hyperview fall into four general categories:</p> <ul> <li><p>Navigation actions, which load new screens and move between them</p></li> <li><p>Update actions, which modify the HXML of the current screen</p></li> <li><p>System actions, which interact with OS-level capabilities.</p></li> <li><p>Custom actions, which can execute any code you add to the client.</p></li> </ul> <section id="navigation-actions" class="level6"> <h6>Navigation actions</h6> <p>We’ve already seen the simplest type of action, <code>push</code>. We classify <code>push</code> as a “navigation action”, since it’s related to navigating screens in the mobile app. Pushing a screen onto the navigation stack is just one of several navigation actions supported in Hyperview. Users also need to be able to go back to previous screens, open and close modals, switch between tabs, or jump to arbitrary screens. Each of these types of navigation is supported through a different value for the <code>action</code> attribute:</p> <ul> <li><p><code>push</code>: Push a new screen into the current navigation stack. This looks like a screen sliding in from the right, on top of the current screen.</p></li> <li><p><code>new</code>: Open a new navigation stack as a modal. This looks like a screen sliding in from the bottom, on top of the current screen.</p></li> <li><p><code>back</code>: This is a complement to the <code>push</code> action. It pops the current screen off of the navigation stack (sliding it to the right).</p></li> <li><p><code>close</code>: This is a complement to the <code>new</code> action. It closes the current navigation stack (sliding it down).</p></li> <li><p><code>reload</code>: Similar to a browser’s “refresh” button, this will re-request the content of the current screen.</p></li> <li><p><code>navigate</code>: This action will attempt to find a screen with the given <code>href</code> already loaded in the app. If the screen exists, the app will jump to that screen. If it doesn’t exist, it will act the same as <code>push</code>.</p></li> </ul> <p><code>push</code>, <code>new</code>, and <code>navigate</code> all load a new screen. Thus, they require an <code>href</code> attribute so that Hyperview knows what content to request for the new screen. <code>back</code> and <code>close</code> do not load new screens, and thus do not require the <code>href</code> attribute. <code>reload</code> is an interesting case. By default, it will use the URL of the screen when re-requesting the content for the screen. However, if you want to replace the screen with a different one, you can provide an <code>href</code> attribute with <code>reload</code> on the behavior element.</p> <p>Let’s look at an example “widgets” app that uses several navigation actions on one screen:</p> <figure> <div class="sourceCode" id="cb17"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">screen</span>></span> <span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">header</span>></span> <span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"back"</span> /> <span class="er"><</span>1></span> <span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a> Back</span> <span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span> <span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"new"</span><span class="ot"> href=</span><span class="st">"/widgets/new"</span> /> <span class="er"><</span>2></span> <span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a> New Widget</span> <span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a> </<span class="kw">header</span>></span> <span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"reload"</span> /> <span class="er"><</span>3></span> <span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a> Check for new widgets</span> <span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a> <<span class="kw">list</span>></span> <span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a> <<span class="kw">item</span><span class="ot"> key=</span><span class="st">"widget1"</span>></span> <span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"push"</span><span class="ot"> href=</span><span class="st">"/widgets/1"</span> /> <span class="er"><</span>4></span> <span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a> </<span class="kw">item</span>></span> <span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a> </<span class="kw">list</span>></span> <span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></<span class="kw">screen</span>></span></code></pre></div> <figcaption><p>Navigation action examples</p></figcaption> </figure> <ol> <li><p>Takes the user to the previous screen</p></li> <li><p>Opens a new modal to add a widget</p></li> <li><p>Reloads the content of the screen, showing new widgets from the backend</p></li> <li><p>Pushes a new screen with details for a specific widget</p></li> </ol> <p>Most screens in your app will need a way for the user to backtrack to the previous screen. This is usually done with a button in the header that uses either a “back” or “close” action, depending on how the screen was opened. In this example, we’re assuming the widgets screen was pushed onto the navigation stack, so the “back” action is appropriate. The header contains a second button that allows the user to enter data for a new widget. Pressing this button will open a modal with a “New Widget” screen. Since this “New Widget” screen will open as a modal, it will need a corresponding “close” action to dismiss itself and show our “widgets” screen again. Finally, to see more details about a specific widget, each <code><item></code> element contains a behavior with a “push” action. This action will push a “Widget Detail” screen onto the current navigation stack. Like in the “Widgets” screen, “Widget Detail” will need a button in the header that uses the “back” action to let the user backtrack.</p> <p>On the web, the browser handles basic navigation needs such as going back/forward, reloading the current page, or jumping to a bookmark. iOS and Android don’t provide this sort of universal navigation for native mobile apps. It’s on the app developers to handle this themselves. Navigation actions in HXML provide an easy but powerful way for developers to build an architecture that makes sense for their app.</p> </section> <section id="update-actions" class="level6"> <h6>Update actions</h6> <p>Behavior actions are not just limited to navigating between screens. They can also be used to change the content on the current screen. We call these “update actions”. Much like navigation actions, update actions make a request to the backend. However, the response is not an entire HXML document, but a fragment of HXML. This fragment is added to the HXML of the current screen, resulting in an update to the UI. The <code>action</code> attribute of the <code><behavior></code> determines how the fragment gets incorporated into the HXML. We also need to introduce a new <code>target</code> attribute on <code><behavior></code> to define where the fragment gets incorporated in the existing doc. The <code>target</code> attribute is an ID reference to an existing element on the screen.</p> <p>Hyperview currently supports these update actions, representing different ways to incorporate the fragment into the screen:</p> <ul> <li><p><code>replace</code>: replaces the entire target element with the fragment</p></li> <li><p><code>replace-inner</code>: replaces the children of the target element with the fragment</p></li> <li><p><code>append</code>: adds the fragment after the last child of the target element</p></li> <li><p><code>prepend</code>: adds the fragment before the first child of the target element.</p></li> </ul> <p>Let’s look at some examples to make this more concrete. For these examples, let’s assume our backend accepts <code>GET</code> requests to <code>/fragment</code>, and the response is a fragment of HXML that looks like <code><text>My fragment</text></code>.</p> <figure> <div class="sourceCode" id="cb18"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">screen</span>></span> <span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"replace"</span><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area1"</span> /> <span class="er"><</span>1></span> <span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a> Replace</span> <span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area1"</span>></span> <span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Existing content</<span class="kw">text</span>></span> <span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span> <span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"replace-inner"</span></span> <span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area2"</span> /> <span class="er"><</span>2></span> <span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a> Replace-inner</span> <span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area2"</span>></span> <span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Existing content</<span class="kw">text</span>></span> <span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span> <span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"append"</span><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area3"</span> /> <span class="er"><</span>3></span> <span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a> Append</span> <span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area3"</span>></span> <span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Existing content</<span class="kw">text</span>></span> <span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a></span> <span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"prepend"</span><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area4"</span> /> <span class="er"><</span>4></span> <span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a> Prepend</span> <span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area4"</span>></span> <span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Existing content</<span class="kw">text</span>></span> <span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a></span> <span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a></<span class="kw">screen</span>></span></code></pre></div> <figcaption><p>Update action examples</p></figcaption> </figure> <ol> <li><p>Replaces the area1 element with fetched fragment</p></li> <li><p>Replaces the child elements of area2 with fetched fragment</p></li> <li><p>Appends the fetched fragment to area3</p></li> <li><p>Prepends the fetched fragment to area4</p></li> </ol> <p>In this example, we have a screen with four buttons corresponding to the four update actions: <code>replace</code>, <code>replace-inner</code>, <code>append</code>, <code>prepend</code>. Below each button, there’s a corresponding <code><view></code> containing some text. Note that the <code>id</code> of each view matches the <code>target</code> on the behaviors of the corresponding button.</p> <p>When the user presses the first button, the Hyperview client makes a request for <code>/fragment</code>. Next, it looks for the target, ie the element with id “area1”. Finally, it replaces the <code><view id="area1"></code> element with the fetched fragment, <code><text>My fragment</text></code>. The existing view and text contained in that view will be replaced. To the user, it will look like “Existing content” was changed to “My fragment”. In the HXML, the element <code><view id="area1"></code> will also be gone.</p> <p>The second button behaves in a similar way to the first one. However, the <code>replace-inner</code> action does not remove the target element from the screen, it only replaces the children. This means the resulting markup will look like <code><view id="area2"><text>My fragment</text></view></code>.</p> <p>The third and fourth buttons do not remove any content from the screen. Instead, the fragment will be added either after (in the case of <code>append</code>) or before (<code>prepend</code>) the children of the target element.</p> <p>For completeness, let’s look at the state of the screen after a user presses all four buttons:</p> <figure> <div class="sourceCode" id="cb19"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">screen</span>></span> <span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"replace"</span><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area1"</span> /> <span class="er"><</span>1></span> <span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a> Replace</span> <span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>My fragment</<span class="kw">text</span>></span> <span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span> <span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"replace-inner"</span></span> <span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area2"</span> /> <span class="er"><</span>2></span> <span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a> Replace-inner</span> <span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area2"</span>></span> <span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>My fragment</<span class="kw">text</span>></span> <span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span> <span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"append"</span><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area3"</span> /> <span class="er"><</span>3></span> <span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a> Append</span> <span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area3"</span>></span> <span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Existing content</<span class="kw">text</span>></span> <span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>My fragment</<span class="kw">text</span>></span> <span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span> <span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"prepend"</span><span class="ot"> href=</span><span class="st">"/fragment"</span><span class="ot"> target=</span><span class="st">"area4"</span> /> <span class="er"><</span>4></span> <span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a> Prepend</span> <span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area4"</span>></span> <span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>My fragment</<span class="kw">text</span>></span> <span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Existing content</<span class="kw">text</span>></span> <span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span> <span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a></<span class="kw">screen</span>></span></code></pre></div> <figcaption><p>Update actions, after pressing buttons</p></figcaption> </figure> <ol> <li><p>Fragment completely replaced the target using <code>replace</code> action</p></li> <li><p>Fragment replaced the children of the target using <code>replace-inner</code> action</p></li> <li><p>Fragment added as last child of the target using <code>append</code> action</p></li> <li><p>fragment added as the first child of the target using <code>prepend</code> action</p></li> </ol> <p>The examples above show actions making <code>GET</code> requests to the backend. But these actions can also make <code>POST</code> requests by setting <code>verb="post"</code> on the <code><behavior></code> element. For both <code>GET</code> and <code>POST</code> requests, the data from the parent <code><form></code> element will be serialized and included in the request. For <code>GET</code> requests, the content will be URL-encoded and added as query params. For <code>POST</code> requests, the content will be form-URL encoded and set on the request body. Since they support <code>POST</code> and form data, update actions are often used to send data to the backend.</p> <p>So far, our example of update actions require getting new content from the backend and adding it to the screen. But sometimes we just want to change the state of existing elements. The most common state to change for an element is its visibility. Hyperview has <code>hide</code>, <code>show</code>, and <code>toggle</code> actions that do just that. Like the other update actions, <code>hide</code>, <code>show</code>, and <code>toggle</code> use the <code>target</code> attribute to apply the action to an element on the current screen.</p> <figure> <div class="sourceCode" id="cb20"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">screen</span>></span> <span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"hide"</span><span class="ot"> target=</span><span class="st">"area"</span> /> <span class="er"><</span>1></span> <span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a> Hide</span> <span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span> <span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"show"</span><span class="ot"> target=</span><span class="st">"area"</span> /> <span class="er"><</span>2></span> <span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a> Show</span> <span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span> <span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"toggle"</span><span class="ot"> target=</span><span class="st">"area"</span> /> <span class="er"><</span>3></span> <span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a> Toggle</span> <span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span> <span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"area"</span>> <span class="er"><</span>4></span> <span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>My fragment</<span class="kw">text</span>></span> <span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></<span class="kw">screen</span>></span></code></pre></div> <figcaption><p>Show, hide, and toggle actions</p></figcaption> </figure> <ol> <li><p>Hides the element with id “area”.</p></li> <li><p>Shows the element with id “area”.</p></li> <li><p>Toggles the visibility of the element with id “area”.</p></li> <li><p>The element targeted by the actions.</p></li> </ol> <p>In this example, the three buttons labeled “Hide”, “Show”, and “Toggle” will modify the display state of the <code><view></code> with ID “area”. Pressing “Hide” multiple times will have no affect once the view is hidden. Likewise, pressing “Show” multiple times will have no affect once the view is showing. Pressing “Toggle” will keep flipping the visibility status of the element between showing and hidden.</p> <p>Hyperview comes with other actions that modify the existing HXML. We won’t cover them in detail, but I’ll mention them briefly here:</p> <ul> <li><p><code>set-value</code>: this action can set the value of an input element such as <code><text-field></code>, <code><switch></code>, <code><select-single></code>, etc.</p></li> <li><p><code>select-all</code> and <code>unselect-all</code> work with the <code><select-multiple></code> element to select/deselect all options.</p></li> </ul> </section> <section id="system-actions" class="level6"> <h6>System actions</h6> <p>Some standard Hyperview actions don’t interact with the HXML at all. Instead, they expose functionality provided by the mobile OS. For example, both Android and iOS support a system-level “Share” UI. This UI allows sharing URLs and messages from one app to another app. Hyperview has a <code>share</code> action to support this interaction. It involves a custom namespace, and share-specific attributes.</p> <figure> <div class="sourceCode" id="cb21"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">behavior</span></span> <span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot"> xmlns:share=</span><span class="st">"https://instawork.com/hyperview-share"</span> <span class="er"><1</span>></span> <span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a> trigger="press"</span> <span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a> action="share" <span class="er"><</span>2></span> <span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a> share:url="https://www.instawork.com" <span class="er"><</span>3></span> <span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a> share:message="Check out this website!" <span class="er"><</span>4></span> <span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>/></span></code></pre></div> <figcaption><p>System share action</p></figcaption> </figure> <ol> <li><p>Defines the namespace for the share action.</p></li> <li><p>The action of this behavior will bring up the share sheet.</p></li> <li><p>URL to be shared.</p></li> <li><p>Message to be shared.</p></li> </ol> <p>We’ve seen XML namespaces when talking about custom elements. Here, we are using a namespace for the <code>url</code> and <code>message</code> attributes on the <code><behavior></code>. These attribute names are generic and likely used by other components and behaviors, so the namespace ensures there will be no ambiguity. When pressed, the “share” action will trigger. The values of the <code>url</code> and <code>message</code> attributes will be passed to the system Share UI. From there, the user will be able to share the URL & message via SMS, email, or other communication apps.</p> <p>The <code>share</code> action shows how a behavior action can use custom attributes to pass along extra data needed for the interactions. But some actions require even more structured data. This can be provided via child elements on the <code><behavior></code>. Hyperview uses this to implement the <code>alert</code> action. The <code>alert</code> action shows a customized system-level dialog box. This dialog needs configuration for a title and message, but also for customized buttons. Each button needs to then trigger another behavior when pressed. This level of configuration cannot be done with just attributes, so we use custom child elements to represent the behavior of each button.</p> <figure> <div class="sourceCode" id="cb22"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">behavior</span></span> <span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot"> xmlns:alert=</span><span class="st">"https://hyperview.org/hyperview-alert"</span> <span class="er"><1</span>></span> <span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a> trigger="press"</span> <span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a> action="alert" <span class="er"><</span>2></span> <span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a> alert:title="Continue to next screen?" <span class="er"><</span>3></span> <span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a> alert:message=</span> <span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a> "Are you sure you want to navigateto the next screen?" <span class="er"><</span>4></span> <span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>></span> <span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a> <<span class="kw">alert:option</span><span class="ot"> alert:label=</span><span class="st">"Continue"</span>> <span class="er"><</span>5></span> <span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> action=</span><span class="st">"push"</span><span class="ot"> href=</span><span class="st">"/next"</span> /> <span class="er"><</span>6></span> <span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a> </<span class="kw">alert:option</span>></span> <span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a> <<span class="kw">alert:option</span><span class="ot"> alert:label=</span><span class="st">"Cancel"</span> /> <span class="er"><</span>7></span> <span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></<span class="kw">behavior</span>></span></code></pre></div> <figcaption><p>System alert action</p></figcaption> </figure> <ol> <li><p>Defines the namespace for the alert action.</p></li> <li><p>The action of this behavior will bring up a system dialog box.</p></li> <li><p>Title of the dialog box.</p></li> <li><p>Content of the dialog box.</p></li> <li><p>A “continue” option in the dialog box</p></li> <li><p>When “continue” is pressed, push a new screen onto the navigation stack.</p></li> <li><p>A “cancel” option that dismisses the dialog box.</p></li> </ol> <p>Like the <code>share</code> behavior, <code>alert</code> uses a namespace to define some attributes and elements. The <code><behavior></code> element itself contains the <code>title</code> and <code>message</code> attributes for the dialog box. The button options for the dialog are defined using a new <code><option></code> element nested in the <code><behavior></code>. Notice that each <code><option></code> element has a label, and then optionally contains a <code><behavior></code> itself! This structure of the HXML allows the system dialog to trigger any interaction that can be defined as a <code><behavior></code>. In the example above, pressing the “Continue” button will open a new screen. But we could just as easily trigger an update action to change the current screen. We could even open a share sheet, or a second dialog box. But please don’t do that in a real app! With great power comes great responsibility.</p> </section> <section id="custom-actions" class="level6"> <h6>Custom actions</h6> <p>You can build a lot of mobile UIs with Hyperview’s standard navigation, update, and system actions. But the standard set may not cover all interactions you will need for your mobile app. Luckily, the action system is extensible. In the same way you can add custom elements to Hyperview, you can also add custom behavior actions. Custom actions have a similar syntax to the <code>share</code> and <code>alert</code> actions, using namespaces for attributes that pass along extra data. Custom actions also have full access to the HXML of the current screen, so they can modify the state or add/remove elements from the current screen. In the next chapter, we will create a custom behavior action to enhance our mobile contacts app.</p> </section> </section> <section id="triggers" class="level5"> <h5>Triggers</h5> <p>We’ve already seen the simplest type of trigger, a <code>press</code> on an element. Hyperview supports many other common triggers used in mobile apps.</p> <section id="id__long_press" class="level6"> <h6>Long-press</h6> <p>Closely related to a press is a long-press. A behavior with <code>trigger="longPress"</code> will trigger when the user presses and holds on the element. “Long-press” interactions are often used for shortcuts and power features. Sometimes, elements will support different actions for both a <code>press</code> and <code>longPress</code>. This is done using multiple <code><behavior></code> elements on the same UI element.</p> <figure> <div class="sourceCode" id="cb23"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">text</span>></span> <span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> trigger=</span><span class="st">"press"</span><span class="ot"> action=</span><span class="st">"push"</span><span class="ot"> href=</span><span class="st">"/next-screen"</span> /> <span class="er"><</span>1></span> <span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> trigger=</span><span class="st">"longPress"</span> <span class="er"><2</span>></span> <span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a> action="push" href="/secret-screen" /></span> <span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a> Press (or long-press) me!</span> <span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></<span class="kw">text</span>></span></code></pre></div> <figcaption><p>Long-press trigger example</p></figcaption> </figure> <ol> <li><p>Normal press will open the next screen.</p></li> <li><p>Long press will open a different screen.</p></li> </ol> <p>In this example, a normal press will open a new screen and request content from <code>/next-screen</code>. However, a long press will open a new screen with content from <code>/secret-screen</code>. This is a contrived example for the sake of brevity. A better UX would be for the long-press to bring up a contextual menu of shortcuts and advanced options. This could be achieved by using <code>action="alert"</code> and opening a system dialog box with the shortcuts.</p> </section> <section id="id__load" class="level6"> <h6>Load</h6> <p>Sometimes we want an action to trigger as soon as the screen loads. <code>trigger="load"</code> does exactly this. One use case is to quickly load a shell of the screen, and then fill in the main content on the screen with a second update action.</p> <figure> <div class="sourceCode" id="cb24"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">body</span>></span> <span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span>></span> <span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>My app</<span class="kw">text</span>></span> <span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> id=</span><span class="st">"container"</span>> <span class="er"><</span>1></span> <span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> trigger=</span><span class="st">"load"</span><span class="ot"> action=</span><span class="st">"replace"</span><span class="ot"> href=</span><span class="st">"/content"</span></span> <span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="ot"> target=</span><span class="st">"container"</span>> <span class="er"><</span>2></span> <span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>Loading...</<span class="kw">text</span>> <span class="er"><</span>3></span> <span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></<span class="kw">body</span>></span></code></pre></div> <figcaption><p>Load trigger example</p></figcaption> </figure> <ol> <li><p>Container element without the actual content</p></li> <li><p>Behavior that immediately fires off a request for /content to replace the container</p></li> <li><p>Loading UI that appears until the content is fetched and replaced.</p></li> </ol> <p>In this example, We load a screen with a heading (“My app”) but no content. Instead, we show a <code><view></code> with ID “container” and some “Loading…​” text. As soon as this screen loads, the behavior with <code>trigger=load</code> fires off the <code>replace</code> action. It requests content from the <code>/content</code> path and replaces the container view with the response.</p> </section> <section id="id__visible" class="level6"> <h6>Visible</h6> <p>Unlike <code>load</code>, the <code>visible</code> trigger will only execute the behavior when the element with the behavior is scrolled into the viewport on the mobile device. The <code>visible</code> action is commonly used to implement an infinite-scroll interaction on a <code><list></code> of <code><item></code> elements. The last item in the list includes a behavior with <code>trigger="visible"</code>. The <code>append</code> action will fetch the next page of items and append them to the list.</p> </section> <section id="id__refresh" class="level6"> <h6>Refresh</h6> <p>This trigger captures a “pull to refresh” action on <code><list></code> and <code><view></code> items. This interaction is associated with fetching up-to-date content from the backend. Thus, it’s typically paired with an update or reload action to show the latest data on the screen.</p> <figure> <div class="sourceCode" id="cb25"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">body</span>></span> <span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">view</span><span class="ot"> scroll=</span><span class="st">"true"</span>></span> <span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> trigger=</span><span class="st">"refresh"</span><span class="ot"> action=</span><span class="st">"reload"</span> /> <span class="er"><</span>1></span> <span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>>No items yet</<span class="kw">text</span>></span> <span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a> </<span class="kw">view</span>></span> <span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></<span class="kw">body</span>></span></code></pre></div> <figcaption><p>Pull-to-refresh trigger example</p></figcaption> </figure> <ol> <li><p>When the view is pulled down to refresh, reload the screen.</p></li> </ol> <p>Note that adding a behavior with <code>trigger="refresh"</code> to a <code><view></code> or <code><list></code> will add the pull-to-refresh interaction to the element, including showing a spinner as the element is pulled down.</p> </section> <section id="id__focus_blur_and_change" class="level6"> <h6>Focus, blur, and change</h6> <p>These triggers are related to interactions with input elements. Thus, they will only trigger behaviors attached to elements like <code><text-field></code>. <code>focus</code> and <code>blur</code> will trigger when the user focuses and blurs the input element, respectively. <code>change</code> will trigger when the value of the input element changes, like when the user types a letter in a text field. These triggers are often used with behaviors that need to perform some server-side validation on the form fields. For example, when the user types in a username and then blurs the field, a behavior could trigger on <code>blur</code> to make a request to the backend and check for uniqueness of the username. If the entered username is not unique, the response could include an error message letting the user know they need to pick a different username.</p> </section> </section> <section id="using-multiple-behaviors" class="level5"> <h5>Using multiple behaviors</h5> <p>Most of the examples shown above attach a single <code><behavior></code> to an element. But there’s no such limitation in Hyperview; elements can define multiple behaviors. We already saw an example where a single element had different actions triggered on <code>press</code> and <code>longPress</code>. But we can also trigger multiple actions on the same trigger.</p> <p>In this admittedly contrived example, we want to hide two elements on the screen when pressing the “Hide” button. The two elements are far apart in the HXML, and cannot be hidden by hiding a common ancestor element. But, we can trigger two behaviors at the same time, each one executing a “hide” action but targeting different elements.</p> <figure> <div class="sourceCode" id="cb26"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><<span class="kw">screen</span>></span> <span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a> <<span class="kw">body</span>></span> <span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span><span class="ot"> id=</span><span class="st">"area1"</span>>Area 1</<span class="kw">text</span>></span> <span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span> <span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span>></span> <span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> trigger=</span><span class="st">"press"</span><span class="ot"> action=</span><span class="st">"hide"</span><span class="ot"> target=</span><span class="st">"area1"</span> /> <span class="er"><</span>1></span> <span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a> <<span class="kw">behavior</span><span class="ot"> trigger=</span><span class="st">"press"</span><span class="ot"> action=</span><span class="st">"hide"</span><span class="ot"> target=</span><span class="st">"area2"</span> /> <span class="er"><</span>2></span> <span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a> Hide</span> <span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a> </<span class="kw">text</span>></span> <span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span> <span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a> <<span class="kw">text</span><span class="ot"> id=</span><span class="st">"area2"</span>>Area 2</<span class="kw">text</span>></span> <span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a> </<span class="kw">body</span>></span> <span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></<span class="kw">screen</span>></span></code></pre></div> <figcaption><p>Multiple behaviors triggering on press</p></figcaption> </figure> <ol> <li><p>Hide element with ID “area1” when pressed.</p></li> <li><p>Hide element with ID “area2” when pressed.</p></li> </ol> <p>Hyperview processes behaviors in the order they appear in the markup. In this case, the element with ID “area1” will be hidden first, followed by the element with ID “area2”. Since “hide” is an instantaneous action (ie, it doesn’t make an HTTP request), both elements will appear to hide simultaneously. But what if we triggered two actions that depend on responses from HTTP requests (like “replace-inner“)? In that case, each individual action is processed as soon as Hyperview receives the HTTP response. Depending on network latency, the two actions could take effect in any order, and they are not guaranteed to be applied simultaneously.</p> <p>We’ve seen elements with multiple behaviors and different triggers. And we’ve seen elements with multiple behaviors with the same trigger. These concepts can be mixed together too. It’s not unusual for a production Hyperview app to contain several behaviors, some triggering together and others triggering on different interactions. Using multiple behaviors with custom actions keeps HXML declarative, without sacrificing functionality.</p> </section> </section> <section id="id__summary" class="level4"> <h4>Summary</h4> <p>We’re covering a lot of new concepts here, and this introduction to HXML just scratches the surface. To learn more about HXML, we recommend consulting the <a href="https://hyperview.org/docs/reference_index">official reference documentation</a>. For now, we hope you come away with a few key takeaways.</p> <p>First, HXML looks and feels similar to HTML. Web developers comfortable with server-side rendering frameworks can use the same techniques to write HXML. In addition to basic UI elements (<code><view></code>, <code><text></code>, <code><image></code>), HXML specifies elements to implement mobile-specific UIs. This includes layout patterns (<code><screen></code>, <code><list></code>, <code><section-list></code>) and input elements (<code><switch></code>, <code><select-single></code>, <code><select-multiple></code>).</p> <p>Second, interactions in HXML are defined using behaviors. Inspired by htmx, <code><behavior></code> elements decouple user interactions (triggers) from the resulting actions. There are three broad categories of behavior actions:</p> <ul> <li><p>Navigation actions (<code>push</code>, <code>back</code>) enable navigating between the screens of a mobile app</p></li> <li><p>Update actions (<code>replace</code>, <code>append</code>) enable updating a screen with new fragments of HXML requested from the server.</p></li> <li><p>System actions (<code>alert</code>, <code>share</code>) enable interacting with system-level functionality on iOS and Android.</p></li> </ul> <p>Finally, HXML itself was designed for customization. Developers can define custom elements and custom behavior actions to expand the possible user interactions with their apps.</p> </section> </section> </x-turndown>`