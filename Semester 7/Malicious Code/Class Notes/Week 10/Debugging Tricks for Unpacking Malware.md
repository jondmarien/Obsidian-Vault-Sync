---
title: Debugging Tricks for Unpacking Malware
author:
  - Jon Marien
created: 2025-03-19
published: 2025-03-19
tags:
  - classes
  - INFO43921
---

| Title                                  | Author                       | Created        | Published      | Tags                                               |
| -------------------------------------- | ---------------------------- | -------------- | -------------- | -------------------------------------------------- |
| Debugging Tricks for Unpacking Malware | <ul><li>Jon Marien</li></ul> | March 19, 2025 | March 19, 2025 | [[#classes\|#classes]], [[#INFO43921\|#INFO43921]] |

# Chapter 17
- Malware author uses  __packers__  to hide his real malware payload by obfuscating it and generating a new packed malware executable/binary that contains within the original malware payload but now in obfuscated form
- Static string analysis of packed samples barely gives you anything meaningful that we can connect to any malicious behavior to classify the sample as malicious.
- To accurately analyze packed samples, we need to extract the actual payload out of the packed binary by using a process called unpacking. There are two types of unpacking techniques, manual and automatic.
- With manual unpacking, we extract the payload by manually debugging/reversing a packed binary with the help of debuggers and disassemblers.
- With automatic unpacking, we extract the payload with the aid of unpacking tools.

## __Unpacking Internals__

- Two very important terminologies related to packed samples and the unpacking process:
	- OEP and payload.

### __OEP and Payload__

We know when an executable/payload is packed by a packer program, a new packed binary is created. The newly created packed binary has the __original executable payload__ embedded in it, in the compressed form. You can say that the payload is delivered to the system or rather executed when the packed binary/sample is executed.

Apart from the obfuscated payload embedded within the packed sample, the packer also embeds a __loader code__ into the packed binary, which sometimes is also referred to as unpacking stub, bootstrap code, and so forth. Now in a packed sample, the entry point (EP) of the packed binary points to the loader code. 

So, when the packed sample is executed, the loader code is the one that is first executed, which is responsible for decompressing the obfuscated payload into the memory. You can say that the loader is the one that unpacks the compressed payload to its original form.

After unpacking, the unpacked payload now extracted is nothing but a PE executable and should also have an entry point like any other PE file. The entry point of the unpacked payload is known as the __original entry point (OEP)__. After the whole unpacking process is carried out by the loader, it then hands over the execution control to the unpacked payload, and it does this by transferring the control to the OEP. The whole process can be illustrated in Figure 17-1.

We now know that the loader code is the one that unpacks the compressed payload to memory and then transfers the control to the OEP inside the unpacked payload.

So, from a reverse engineering perspective, if we want to unpack a packed binary, we need to debug and skip through the loader code and figure out the point of transition into the unpacked payload.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_0.png)

## __Execution of a Packed Binary__
- When a packed binary is executed, the code execution can be split into two parts: one that belongs to the loader and one that belongs to the unpacked payload. Listed next are the various stages that occur when a packed binary is executed.
	- **Memory allocation:** The loader allocates memory to dump the decompressed payload into.
	- **Payload decompression:** The loader decompresses the packed payload to the allocated memory in (1).
	- **Import resolution:** The various addresses inside the decompressed payload , including the addresses of the Win32 APIs needed by the payload, are resolved.
	- **Jump to OEP:** The loader transfers control to the OEP which is the start of the payload.
	- **Payload execution:** The payload now runs, carrying out its malicious activity.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_1.png)

## __APIs for unpacking__
We are going to take the help of our `APIMiner` tool to obtain the Win32 APIs involved in various phases of execution. Do note that `APIMiner` logs the `ntdll(NT)` variant of Win32 APIs. So, if you are used to working and seeing non-NT versions of Win32 APIs, you might have to mentally convert these NT API names logged by `APIMiner` to its corresponding non-NT version. In the end, they are all the same, because Win32 APIs, in the end, are wrappers that end up calling their corresponding NT version of Win32 APIs. Finally, what we want to learn is the functionality of the API that is invoked, which reveals the intention of why the malware sample invoked it.

Table 17-1 lists the mapping between some important NT APIs and the corresponding non-NT Win32 wrapper APIs that invoke them.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_2.png)

## __Memory Allocation__

As an exercise, run Sample-17-1 malware sample from the samples repo using APIMiner. This is a packed sample, and if you go through the API logs generated, you see the memory allocations done by the sample’s loader code, as seen in Figure 17-3. Do note that the addresses allocated on your system might vary from the ones you see in the figure, but look for the same API call sequence patterns in your APIMiner logs.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_3.png)

Alternatively, some of the loaders may prefer to  __overwrite some existing memory__ space already available in the sample’s running process memory space, which means you may not see any calls to allocate memory, or at least not as many memory allocation-related API calls. For such cases, instead, you might encounter APIs like  `VirtualProtect`  and  `NtProtectVirtualMemory` , that change the  __permission__  of a memory region to writable and executable so that the loader can write and execute code from it.

In this stage, the loader unpacks/decompresses the compressed payload to the allocated memory regions from the previous step. The payload is unpacked into the allocated memory using decompression algorithms . These algorithms perform __a lot of mathematical operations__ , and you see only raw assembly code instead of any Win32 APIs being invoked by this piece of decompression code. If you are lucky enough, you might encounter some malware using `RtlDecompressBuffer` Win32 API, which implements certain decompression algorithms.

Now the unpacked payload that is written to memory is usually an executable. It also __has a PE header__  and __an entry point__ , which we call the OEP. Do note that it’s not necessary to accommodate the entire payload into a single memory block. The headers, individual sections can be in separate memory blocks.

If we consider the first two steps, memory allocation, and decompression, there is a considerable change in the virtual memory map of the packed binary process when these two stages are hit. Figure 17-4 represents the changes in the virtual memory map of a packed sample as it goes through these two steps.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_4.png)

## __Import Resolution__
Since the payload has been unpacked into the memory, it’s time to make some fixes so that code inside it can be executed.

A PE Executable depends on various Win32 APIs to execute certain functionalities that it might need. These APIs are imported by the executable, which are present in the executable’s __import table__. If you look at the traditional process creation mechanism when the executable/program is executed, the Windows loader goes through, all the APIs that the program depends on by parsing through the program’s import table list, __loads into memory the various DLLs the process needs and then resolves the addresses of these APIs__  in the import table. This mechanism of finding and resolving the addresses of the imported APIs that a program depends on is called __import resolution__. Without import resolution, a process can’t invoke any API it ==needs==, since it won’t know where in memory it is located.

Let’s connect to the packed samples and the unpacking process. __A packed binary-only imports a few APIs that are required by the loader__. But from our previous decompression stage, the payload, which has been decompressed, depends on a lot of Win32 APIs to carry out its malicious intentions. Who handles the import resolution for this unpacked payload? It won’t be the Windows loader because it is only called for help by the OS when it needs to load a new process from a program on disk. So, in our case, it’s our loader stub code inside our packed binary, which must do the import resolution for the unpacked payload.

Getting into the internals of how the loader does import resolution, the loader reads the import table of the unpacked payload to find out the names of the imported APIs the payload depends on. But before it can find the address of an API, the loader first needs to load the DLL that contains the API. This is done by using the `LoadLibrary` API. The `LoadLibrary` API returns the address of the DLL after successfully loading the dependency DLL into memory. This address is then used by the loader as a parameter to the `GetProcAddress` API to find the address of the API located in the DLL.

Listing 17-1 shows the usage of `Loadlibrary` and `GetProcAddress` to retrieve the address of the `VirtualAlloc` API, which is in `kernel32.dll`.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_5.png)

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_6.png)

**OEP** is the address of the instruction that is supposed to be executed first when the loader transfers the execution to the unpacked payload.

The loader transfers the control to the **OEP**, usually using an unconditional jump instruction .

The loader usually unpacks the entire payload in one chunk to a single big memory block, so you can say that the loader and payload are in separate memory blocks. When the loader jumps to the OEP, it transfers the control from one memory block to another.

## __The Payload Execution__
- With the control now transferred to the unpacked payload’s OEP, the payload now executes carrying out its malicious functionality.
- While reversing malware samples, you can use your knowledge of the APIs that most malware (present in an unpacked payload) invoke, and search for the presence of API invocations in your APIMiner API logs, which indicate if you are inside the unpacked payload or still inside the loader code.
- Here are some of the API types you should look for to find out if you are inside the payload.
	- Creation of new files on the disk.
	- Writing to files.
	- Creation of registry keys and values.
	- Network connections.
	- New process creation.
	- Opening and writing into remote processes.
	- Creating threads in remote processes.

Figure 17-6 shows that the `RegCreateKey` API creates a new registry key "`Software\uRyIZ15LWxSYAJ4`". There is a rare chance that these kinds of APIs are called by the loader code, and hence these APIs must have been invoked by the unpacked payload.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_7.png)

## __Manual Unpacking Using Debuggers__
- Manual unpacking requires analysts to debug packed binaries and extract the payload out of it. Our understanding of the execution of packed binary and the various stages of unpacking can help us to locate the payload inside the packed binary. And a super important trick that can help us fast unpack a sample is using tools like APIMiner and API logs.
- Now manual unpacking involves two main goals.
	- Locating the unpacked or decompressed payload in memory.
	- Dumping the payload to disk for further analysis.

__Debugging Tricks for Known Packers__

Malware authors also use well-known packers to pack malware. One of the commonly used packers is UPX. Other popular packers include `aspack`, `ascompact`, `PEcompact`, `nspack`, `mpack`, `yoda`, and so forth. The loader in the packed samples generated by these packers can have thousands of lines of assembly code, and going through each of these to reach the unpacked payload consumes. Malware researchers have developed debugging tricks over time that can help you to skip the loader code and reach the OEP of the unpacked payload directly.

Now the first step of unpacking known packers is to identify the packer. In Chapter 7, we discussed identifying packers using the entry point and section names. Let’s start with Sample-17-2.exe from our samples repo. Apply the static analysis technique from Chapter 7 on this sample, which should reveal that sample is packed using UPX. Now that we know the packer is UPX, if you Google unpacking UPX, you find a commonly used trick called the ESP trick that can locate the OEP for UPX packed samples. What is this ESP trick?

The entry point of a UPX packed binary starts with a PUSHAD instruction. In other words, PUSHAD is the first instruction in a UPX packed sample. A PUSHAD instruction pushes all the registers onto the stack. Once the loader in the UPX packed sample does its job of decompressing/unpacking the payload to memory, it restores the original state of the registers, which is pushed at the very start using the PUSHAD instruction. To do that, it uses the POPAD instruction, which accesses and reads the address locations on the stack to read them and restore the registers. Once it has restored the registers using the POPAD instruction, it then does an unconditional JMP into the OEP of the unpacked payload. So, you can conclude that for UPX packed samples, the loader code pretty much ends unpacking the payload at the POPAD instruction right after which it does the unconditional JMP to the OEP.

We can exploit this pattern in the UPX loader code to figure out the exact location of the OEP. If we can set a memory breakpoint on the stack address after the first PUSHAD instruction is executed, we can break at the exact point the loader code calls POPAD, thereby taking us to an instruction location in the loader code that is a few instructions behind the conditional JMP to the OEP. And that’s the ESP trick. Let’s now try this out hands-on.

Let’s load Sample-17-2.exe from our samples repo using OllyDbg, which breaks at the entry point of the packed sample, which is the PUSHAD instruction. Step over this instruction using the F8 key. Now the registers are pushed on to the stack. Let’s go to the location to get to the address block of the stack in the memory window. You can do this by right-clicking the ESP register and choosing the Follow in dump option. The other option you can use is to go to the memory window, and key in ESP using Ctrl+G and hit the Enter key. This should load the memory block starting from the address in ESP (i.e., 0x12FF6C) in the memory window, as seen in Figure 17-8. You can now place a hardware breakpoint on access on a DWORD at the first address of this memory block pointed to by the ESP (i.e., 0x12FF6C).

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_8.png)

Now when the hardware breakpoint is set, you see the four bytes at address 0x12FF6C highlighted in red, as seen in Figure 17-8. This means that next time someone tries to access this memory location, OllyDbg pauses/breaks execution right after the instruction that accesses that memory location. But we also learned that with UPX packed loader code, it access this memory location when it does a POPAD, which is where we break. Let’s test it.

You can now continue running the sample using F9 and, as expected, OllyDbg breaks right after POPAD instruction at 0xAAA7416, since this POPAD instruction tried to access 0x12FF6C on which we have placed a hardware breakpoint on access, as seen in Figure 17-9.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_9.png)

You learned from the ESP trick that the pattern used in UPX packed sample’s loader code is that when it hits the POPAD, the loader has finished decompressing the payload and shortly be jumping into the OEP. As you can see in Figure 17-9, if you scroll a few instructions down after the POPAD, you can locate an unconditional JMP instruction at address 0xAAA7423, which jumps into 0x00408701, which is the OEP of the unpacked payload.

Also, observe the address of the unconditional jump instruction at 0xAAA7423, which starts with the address 0x0AAA, while the target address of the jump (i.e., 0x00408701) starts with the address 0x0040 which means they lie in different memory blocks. You can check the memory map in OllyDbg to verify if these two addresses are located in different memory blocks, as seen in Figure 17-10.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_10.png)

This reveals that the current unconditional JMP instruction at address 0xAAA7423 in Figure 17-9 lies in the loader code, and the target of the jump (i.e., 0x00408701) are in different memory blocks. From what you learned in the section Unpacking Internals a jump to OEP usually takes you to a different memory block, which also acts as a classic indicator that this JMP instruction transitions to the OEP of the unpacked payload.

If you now step into the JMP 00408701 instruction, you are going to land at the OEP (i.e., the first instruction in the unpacked payload), as seen in Figure 17-11.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_11.png)

if you wish to debug further into the payload, you can debug further from here. If you want to extract the payload onto a file in the disk, you can use a memory dumping tool like OllyDump using the OllyDumpEx plugins, which you can then analyze using static analysis tools like IDA Pro.

## __OllyDumpEx to Dump Payloads__
To dump the payload from memory to the disk, you can use the OllyDumpEx plugin for OllyDbg, by using Plugins ➤ OllyDumpEx ➤ Dump process option in OllyDbg’s menu bar, which should open the OllyDumpEx window, as seen in Figure 17-12.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_12.png)

Figure 17-12 displays various settings and steps required to dump the payload to the disk, the steps for which we have listed next.

Step 1: The first step is to choose the base address of the payload from which the dumping should start. You can say this is the address of the first byte of the payload, which starts with the MZ header. In this case, the payload is the main module itself. If you find the payload in a memory block, OllyDumpEx gives an option to specify the memory block.

Step 2: In this step, you need to select the dump option. If you choose the rebuild option, OllyDumpEx tries to build a valid PE executable out of the payload in memory. We always prefer to choose this option. Rebuild option might not work in case the packer uses some anti-dumping tricks or has heavily tampered the import table. In such cases, you need to use other tools like Imprec to manually fix the imports.

Step 3: The next step is to choose the entry point of the payload. OllyDumpEx can guess the entry point if it knows the image base or base. In this case, we are dumping starting at the OEP, which we know is the Entry point of the payload. Hence, we can click the Get EIP as OEP button.

Step 4: OlldyDumpEx can also find sections in the payload by parsing the payload by assuming the payload is a PE executable. It displays the possible sections in the payload, and we can manually choose the sections which we want to be present in the output dump.

Now when we have set all the fields in the plugin window, we can dump the payload to the disk. You can now click the Dump button and then save it a folder of your choice. The same options we chose this time would not work for each kind of packer. You need to try out different options for different kinds of packed binaries.

Now you have the payload at your disposal for analysis. If the dumping has been correctly done, the payload demonstrates the same behavior as the packed binary. The API traces vary since the new entry point points to the OEP in the payload and not to the loader. So, all the Win32 APIs that previously were invoked by the loader in the packed sample are no longer present in the API logs, since the loader code has been removed from the dumped payload.

Do note that sometimes it is hard to accurately dump the payload. As a result, the dumped payload cannot be loaded in debuggers. In that case, you can perform static analysis on the dumped payload using tools like IDA Pro and also conduct string analysis on it.

The ESP trick applies to some other known packers like ASpack. The pattern of JMP to OEP we displayed is specific to UPX, but other known packers can have similar patterns. Like the ESP trick, researchers have devised other tricks to unpack known packers. If your packer identification tool like PEid can identify a packer used for an executable, you can look out for unpacking tricks on the web for the identified packer.

Loaders can allocate memory areas to decrypt/decompress payloads or parts of payloads into these areas. As a debugging trick, you can __set a breakpoint on memory allocation APIs like VirtualAlloc__ to find out what memory areas that are getting allocated. With the address of these allocated memory blocks known, we can keep a watch on these areas using __hardware and memory breakpoints__ to see if anything interesting is getting written to these locations. You can inspect the content of the memory areas in the memory dump window of OllyDbg, or you can use Process Hacker for the purpose as well. If you have set a memory breakpoint on these address blocks, OllyDbg break execution if the loader writes any data to these memory blocks.

Other than placing breakpoints, you should look carefully for certain code constructs like loops in the loader code. The __loader code can use loops for decompression or decryption purposes__. If the memory write operation is happening in loops, you should look at the memory region that’s getting written into. It can be a payload or part of the payload.

Other interesting loops can be the __import resolution loops__. The import resolution loops indicate that we are toward the end of the loader code and are soon going to reach the OEP. After executing the import resolution, you can start stepping line by line and watch out for any unconditional jump instructions, which might be a jump to OEP.

## __Compiler Stubs to Identify OEP__
Most of the time, malware payloads are compiled using a high-level language like C++, VB, Delphi, and so forth. Compilers have code known as a compiler stub in between the entry point of the program and the `main() `function written by the programmer. The `main()` function is not usually the OEP, since you have various other compiler stub and setup code that is first run before your main() function is called. This compiler stub code is usually the entry point of a program.

__The compiler stubs usually have some kind of pattern__ that can identify the compiler used. Now __when we reach the OEP in the payload, we can say that it should start with a compiler stub__ unless the payload has been created out of raw assembly language. 

As an example, Figure 17-13 shows the code around the OEP of a UPX packed sample, we unpacked in the previous section, where the original payload sample has been compiled using Visual Studio’s VC++ compiler.

![](M11-1-Debugging%20Tricks%20for%20Unpacking%20Malware-2024_13.png)

As you can see, the code at the OEP starts with a CALL instruction followed by a JMP instruction. This instruction sequence is usually a combination found at the entry points of VC++ compiled executables. Armed with the knowledge of compiler stub patterns, you can a lot of times easily notice the entry point of the payload.

But watch out for some corner cases. It can so happen that a payload has been packed with multiple layers of packers. If the packers themselves have been programmed in high-level languages and have been compiled using compilers like VC++, you see multiple compiler-related stubs as you go through multiple layers of unpacking, which can mislead you into thinking that you are at the OEP of the unpacked payload. So, you always need other double verification steps like the ones we talk about in the next few sections to confirm if you are finally inside the unpacked payload or not.